js_str = """
//time 2019-04-04

var _$_543c = ["\x75\x6E\x64\x65\x66\x69\x6E\x65\x64", "\x66\x75\x6E\x63\x74\x69\x6F\x6E", "\x6F\x62\x6A\x65\x63\x74", "\x67\x6C\x6F\x62\x61\x6C", "\x77\x69\x6E\x64\x6F\x77", "\x73\x65\x6C\x66", "\x4F\x62\x6A\x65\x63\x74", "\x4E\x75\x6D\x62\x65\x72", "\x53\x74\x72\x69\x6E\x67", "\x44\x61\x74\x65", "\x53\x79\x6E\x74\x61\x78\x45\x72\x72\x6F\x72", "\x54\x79\x70\x65\x45\x72\x72\x6F\x72", "\x4D\x61\x74\x68", "\x4A\x53\x4F\x4E", "\x62\x75\x67\x2D\x73\x74\x72\x69\x6E\x67\x2D\x63\x68\x61\x72\x2D\x69\x6E\x64\x65\x78", "\x61", "\x6A\x73\x6F\x6E", "\x6A\x73\x6F\x6E\x2D\x73\x74\x72\x69\x6E\x67\x69\x66\x79", "\x6A\x73\x6F\x6E\x2D\x70\x61\x72\x73\x65", "\x7B\x22\x61\x22\x3A\x5B\x31\x2C\x74\x72\x75\x65\x2C\x66\x61\x6C\x73\x65\x2C\x6E\x75\x6C\x6C\x2C\x22\x5C\x75\x30\x30\x30\x30\x5C\x62\x5C\x6E\x5C\x66\x5C\x72\x5C\x74\x22\x5D\x7D", "\x30", "\x22\x22", "\x31", "\x5B\x31\x5D", "\x5B\x6E\x75\x6C\x6C\x5D", "\x6E\x75\x6C\x6C", "\x5B\x6E\x75\x6C\x6C\x2C\x6E\x75\x6C\x6C\x2C\x6E\x75\x6C\x6C\x5D", "\x00\x08\x0A\x0C\x0D\x09", "\x5B\x0A\x20\x31\x2C\x0A\x20\x32\x0A\x5D", "\x22\x2D\x32\x37\x31\x38\x32\x31\x2D\x30\x34\x2D\x32\x30\x54\x30\x30\x3A\x30\x30\x3A\x30\x30\x2E\x30\x30\x30\x5A\x22", "\x22\x2B\x32\x37\x35\x37\x36\x30\x2D\x30\x39\x2D\x31\x33\x54\x30\x30\x3A\x30\x30\x3A\x30\x30\x2E\x30\x30\x30\x5A\x22", "\x22\x2D\x30\x30\x30\x30\x30\x31\x2D\x30\x31\x2D\x30\x31\x54\x30\x30\x3A\x30\x30\x3A\x30\x30\x2E\x30\x30\x30\x5A\x22", "\x22\x31\x39\x36\x39\x2D\x31\x32\x2D\x33\x31\x54\x32\x33\x3A\x35\x39\x3A\x35\x39\x2E\x39\x39\x39\x5A\x22", "\x22\x09\x22", "\x30\x31", "\x31\x2E", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x46\x75\x6E\x63\x74\x69\x6F\x6E\x5D", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x44\x61\x74\x65\x5D", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x4E\x75\x6D\x62\x65\x72\x5D", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x53\x74\x72\x69\x6E\x67\x5D", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x41\x72\x72\x61\x79\x5D", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x42\x6F\x6F\x6C\x65\x61\x6E\x5D", "\x76\x61\x6C\x75\x65\x4F\x66", "\x74\x6F\x53\x74\x72\x69\x6E\x67", "\x74\x6F\x4C\x6F\x63\x61\x6C\x65\x53\x74\x72\x69\x6E\x67", "\x70\x72\x6F\x70\x65\x72\x74\x79\x49\x73\x45\x6E\x75\x6D\x65\x72\x61\x62\x6C\x65", "\x69\x73\x50\x72\x6F\x74\x6F\x74\x79\x70\x65\x4F\x66", "\x68\x61\x73\x4F\x77\x6E\x50\x72\x6F\x70\x65\x72\x74\x79", "\x63\x6F\x6E\x73\x74\x72\x75\x63\x74\x6F\x72", "\x70\x72\x6F\x74\x6F\x74\x79\x70\x65", "\x5C\x5C", "\x5C\x22", "\x5C\x62", "\x5C\x66", "\x5C\x6E", "\x5C\x72", "\x5C\x74", "\x30\x30\x30\x30\x30\x30", "\x5C\x75\x30\x30", "\x22", "", "\x74\x6F\x4A\x53\x4F\x4E", "\x2D", "\x2B", "\x54", "\x3A", "\x2E", "\x5A", "\x5B\x0A", "\x2C\x0A", "\x0A", "\x5D", "\x5B", "\x2C", "\x5B\x5D", "\x20", "\x7B\x0A", "\x7D", "\x7B", "\x7B\x7D", "\x5C", "\x2F", "\x08", "\x09", "\x0C", "\x0D", "\x40", "\x30\x78", "\x74\x72\x75\x65", "\x66\x61\x6C\x73\x65", "\x24", "\x73\x74\x72\x69\x6E\x67", "\x72\x75\x6E\x49\x6E\x43\x6F\x6E\x74\x65\x78\x74", "\x4A\x53\x4F\x4E\x33", "\x75\x73\x65\x20\x73\x74\x72\x69\x63\x74", "\x2E\x2F\x69\x73\x41\x72\x67\x75\x6D\x65\x6E\x74\x73", "\x4F\x62\x6A\x65\x63\x74\x2E\x6B\x65\x79\x73\x20\x63\x61\x6C\x6C\x65\x64\x20\x6F\x6E\x20\x61\x20\x6E\x6F\x6E\x2D\x6F\x62\x6A\x65\x63\x74", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x41\x72\x67\x75\x6D\x65\x6E\x74\x73\x5D", "\x6E\x75\x6D\x62\x65\x72", "\x2E\x2F\x7A\x6C\x69\x62\x2F\x64\x65\x66\x6C\x61\x74\x65", "\x2E\x2F\x75\x74\x69\x6C\x73\x2F\x63\x6F\x6D\x6D\x6F\x6E", "\x2E\x2F\x75\x74\x69\x6C\x73\x2F\x73\x74\x72\x69\x6E\x67\x73", "\x2E\x2F\x7A\x6C\x69\x62\x2F\x6D\x65\x73\x73\x61\x67\x65\x73", "\x2E\x2F\x7A\x6C\x69\x62\x2F\x7A\x73\x74\x72\x65\x61\x6D", "\x5B\x6F\x62\x6A\x65\x63\x74\x20\x41\x72\x72\x61\x79\x42\x75\x66\x66\x65\x72\x5D", "\x6D\x75\x73\x74\x20\x62\x65\x20\x6E\x6F\x6E\x2D\x6F\x62\x6A\x65\x63\x74", "\x2E\x2F\x63\x6F\x6D\x6D\x6F\x6E", "\x2E\x2E\x2F\x75\x74\x69\x6C\x73\x2F\x63\x6F\x6D\x6D\x6F\x6E", "\x2E\x2F\x74\x72\x65\x65\x73", "\x2E\x2F\x61\x64\x6C\x65\x72\x33\x32", "\x2E\x2F\x63\x72\x63\x33\x32", "\x2E\x2F\x6D\x65\x73\x73\x61\x67\x65\x73", "\x70\x61\x6B\x6F\x20\x64\x65\x66\x6C\x61\x74\x65\x20\x28\x66\x72\x6F\x6D\x20\x4E\x6F\x64\x65\x63\x61\x20\x70\x72\x6F\x6A\x65\x63\x74\x29", "\x6E\x65\x65\x64\x20\x64\x69\x63\x74\x69\x6F\x6E\x61\x72\x79", "\x73\x74\x72\x65\x61\x6D\x20\x65\x6E\x64", "\x66\x69\x6C\x65\x20\x65\x72\x72\x6F\x72", "\x73\x74\x72\x65\x61\x6D\x20\x65\x72\x72\x6F\x72", "\x64\x61\x74\x61\x20\x65\x72\x72\x6F\x72", "\x69\x6E\x73\x75\x66\x66\x69\x63\x69\x65\x6E\x74\x20\x6D\x65\x6D\x6F\x72\x79", "\x62\x75\x66\x66\x65\x72\x20\x65\x72\x72\x6F\x72", "\x69\x6E\x63\x6F\x6D\x70\x61\x74\x69\x62\x6C\x65\x20\x76\x65\x72\x73\x69\x6F\x6E", "\x26", "\x3D", "\x25\x32\x30", "\x62\x6F\x6F\x6C\x65\x61\x6E", "\x2E\x2F\x64\x65\x63\x6F\x64\x65", "\x2E\x2F\x65\x6E\x63\x6F\x64\x65", "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x2B\x2F", "\x70\x61\x6B\x6F\x2F\x6C\x69\x62\x2F\x64\x65\x66\x6C\x61\x74\x65", "\x2E\x2F\x62\x74\x6F\x61", "\x71\x75\x65\x72\x79\x73\x74\x72\x69\x6E\x67", "\x2E\x2F\x77\x65\x62\x64\x72\x69\x76\x65\x72", "\x6F\x62\x6A\x65\x63\x74\x2D\x6B\x65\x79\x73", "\x46\x75\x6E\x63\x74\x69\x6F\x6E\x2E\x70\x72\x6F\x74\x6F\x74\x79\x70\x65\x2E\x62\x69\x6E\x64\x20\x2D\x20\x77\x68\x61\x74\x20\x69\x73\x20\x74\x72\x79\x69\x6E\x67\x20\x74\x6F\x20\x62\x65\x20\x62\x6F\x75\x6E\x64\x20\x69\x73\x20\x6E\x6F\x74\x20\x63\x61\x6C\x6C\x61\x62\x6C\x65", "\x6A\x73\x6F\x6E\x33", "\x70\x73", "\x74\x6F\x6B\x65\x6E", "\x5F\x74\x6F\x6B\x65\x6E", "\x31\x2E\x30\x2E\x36", "\x73\x72\x63\x45\x6C\x65\x6D\x65\x6E\x74", "\x6F\x6E", "\x6D\x6F\x75\x73\x65\x6D\x6F\x76\x65", "\x6B\x65\x79\x64\x6F\x77\x6E", "\x63\x6C\x69\x63\x6B", "\x6F\x6E\x74\x6F\x75\x63\x68\x6D\x6F\x76\x65", "\x74\x6F\x75\x63\x68\x6D\x6F\x76\x65", "\x3F", "\x68\x61\x73\x41\x74\x74\x72\x69\x62\x75\x74\x65", "\x77\x65\x62\x64\x72\x69\x76\x65\x72", "\x5F\x5F\x64\x72\x69\x76\x65\x72\x5F\x65\x76\x61\x6C\x75\x61\x74\x65", "\x5F\x5F\x77\x65\x62\x64\x72\x69\x76\x65\x72\x5F\x65\x76\x61\x6C\x75\x61\x74\x65", "\x5F\x5F\x73\x65\x6C\x65\x6E\x69\x75\x6D\x5F\x65\x76\x61\x6C\x75\x61\x74\x65", "\x5F\x5F\x66\x78\x64\x72\x69\x76\x65\x72\x5F\x65\x76\x61\x6C\x75\x61\x74\x65", "\x5F\x5F\x64\x72\x69\x76\x65\x72\x5F\x75\x6E\x77\x72\x61\x70\x70\x65\x64", "\x5F\x5F\x77\x65\x62\x64\x72\x69\x76\x65\x72\x5F\x75\x6E\x77\x72\x61\x70\x70\x65\x64", "\x5F\x5F\x73\x65\x6C\x65\x6E\x69\x75\x6D\x5F\x75\x6E\x77\x72\x61\x70\x70\x65\x64", "\x5F\x5F\x66\x78\x64\x72\x69\x76\x65\x72\x5F\x75\x6E\x77\x72\x61\x70\x70\x65\x64", "\x5F\x5F\x77\x65\x62\x64\x72\x69\x76\x65\x72\x46\x75\x6E\x63", "\x5F\x53\x65\x6C\x65\x6E\x69\x75\x6D\x5F\x49\x44\x45\x5F\x52\x65\x63\x6F\x72\x64\x65\x72", "\x5F\x73\x65\x6C\x65\x6E\x69\x75\x6D", "\x63\x61\x6C\x6C\x65\x64\x53\x65\x6C\x65\x6E\x69\x75\x6D", "\x64\x6F\x6D\x41\x75\x74\x6F\x6D\x61\x74\x69\x6F\x6E", "\x64\x6F\x6D\x41\x75\x74\x6F\x6D\x61\x74\x69\x6F\x6E\x43\x6F\x6E\x74\x72\x6F\x6C\x6C\x65\x72", "\x5F\x5F\x6C\x61\x73\x74\x57\x61\x74\x69\x72\x41\x6C\x65\x72\x74", "\x5F\x5F\x6C\x61\x73\x74\x57\x61\x74\x69\x72\x43\x6F\x6E\x66\x69\x72\x6D", "\x5F\x5F\x6C\x61\x73\x74\x57\x61\x74\x69\x72\x50\x72\x6F\x6D\x70\x74", "\x64\x77", "\x64\x65", "\x64\x69", "\x77\x66", "\x77\x77\x74", "\x77\x77", "\x67\x77", "\x5F\x5F\x77\x65\x62\x64\x72\x69\x76\x65\x72\x5F\x73\x63\x72\x69\x70\x74\x5F\x66\x6E", "\x43\x68\x72\x6F\x6D\x65\x44\x72\x69\x76\x65\x72\x77\x6A\x65\x72\x73\x39\x30\x38\x66\x6C\x6A\x73\x64\x66\x33\x37\x34\x35\x39\x66\x73\x64\x66\x67\x64\x66\x77\x72\x75\x3D", "\x24\x63\x64\x63\x5F\x61\x73\x64\x6A\x66\x6C\x61\x73\x75\x74\x6F\x70\x66\x68\x76\x63\x5A\x4C\x6D\x63\x66\x6C\x5F", "\x24\x63\x68\x72\x6F\x6D\x65\x5F\x61\x73\x79\x6E\x63\x53\x63\x72\x69\x70\x74\x49\x6E\x66\x6F", "\x5F\x57\x45\x42\x44\x52\x49\x56\x45\x52\x5F\x45\x4C\x45\x4D\x5F\x43\x41\x43\x48\x45", "\x5F\x5F\x24\x77\x65\x62\x64\x72\x69\x76\x65\x72\x41\x73\x79\x6E\x63\x45\x78\x65\x63\x75\x74\x6F\x72", "\x63\x64\x5F\x66\x72\x61\x6D\x65\x5F\x69\x64\x5F", "\x69\x66\x72\x61\x6D\x65", "\x66\x72\x61\x6D\x65", "\x64\x72\x69\x76\x65\x72\x2D\x65\x76\x61\x6C\x75\x61\x74\x65", "\x77\x65\x62\x64\x72\x69\x76\x65\x72\x2D\x65\x76\x61\x6C\x75\x61\x74\x65", "\x73\x65\x6C\x65\x6E\x69\x75\x6D\x2D\x65\x76\x61\x6C\x75\x61\x74\x65", "\x77\x65\x62\x64\x72\x69\x76\x65\x72\x43\x6F\x6D\x6D\x61\x6E\x64", "\x77\x65\x62\x64\x72\x69\x76\x65\x72\x2D\x65\x76\x61\x6C\x75\x61\x74\x65\x2D\x72\x65\x73\x70\x6F\x6E\x73\x65", "\x6C\x77\x65", "\x66", "\x76", "\x70", "\x68", "\x6C", "\x53", "\x6C\x77\x63", "\x43\x61\x6E\x6E\x6F\x74\x20\x66\x69\x6E\x64\x20\x6D\x6F\x64\x75\x6C\x65\x20\x27", "\x27", "\x4D\x4F\x44\x55\x4C\x45\x5F\x4E\x4F\x54\x5F\x46\x4F\x55\x4E\x44"];
var iK = function() {
    if (window._phantom || window.phantom || window.callPhantom) {
        return _$_543c[135]
    }
    ;return iQ.getWebdriver()
};
var iP = {
    rId: 100023,
    ver: "1.0.6",
    ts: new Date().getTime(),
    cts: new Date().getTime(),
    brVD: [375,812],
    brR: [[375, 812],[375, 812],24,24],
          //  Referer
    bI: ["https://m.waimai.meituan.com/waimai/mindex/home?__="+new Date().getTime(),''],
    mT: [],
    kT: [],
    aT: [],
    tT: [],
    aM: '',   
};
z = {};
Y = z.toString
function t_1(t) {
    return null == t ? String(t) : z[Y.call(t)] || "object"
}
function e_1(e) {
    return "function" == t_1(e)
}
function i_1(e) {
    return "object" == t_1(e)
}
function n_1(t) {
    return null != t && t == t.window
}
function a_1(t) {
    return i_1(t) && !n_1(t) && Object.getPrototypeOf(t) == Object.prototype
}
function c_1(t) {
    return "number" == typeof t.length
}

function each(t, e) {
    var n, r;
    if (c_1(t)) {
        for (n = 0; n < t.length; n++)
            if (!1 === e.call(t[n], n, t[n]))
                return t
    } else
        for (r in t)
            if (!1 === e.call(t[r], r, t[r]))
                return t;
    return t
}
function v(e, n, r, o) {
    var i, a = Array.isArray(n), c = a_1(n);
    each(n, function(n, u) {
        i = t_1(u),
        o && (n = r ? o : o + "[" + (c || "object" == i || "array" == i ? n : "") + "]"),
            !o && a ? e.add(u.name, u.value) : "array" == i || !r && "object" == i ? v(e, u, r, n) : e.add(n, u)
    })
}
var P = encodeURIComponent;

function ik(dl, ix) {
    return Object.prototype.hasOwnProperty.call(dl, ix)
}
function exports(ir, it, im, de) {
    it = it || _$_543c[121];
    im = im || _$_543c[122];
    var dl = {};
    if (typeof ir !== _$_543c[91] || ir.length === 0) {
        return dl
    }
    ;var is = /\+/g;
    ir = ir.split(it);
    var iq = 1000;
    if (de && typeof de.maxKeys === _$_543c[98]) {
        iq = de.maxKeys
    }
    ;var ds = ir.length;
    if (iq > 0 && ds > iq) {
        ds = iq
    }
    ;for (var cs = 0; cs < ds; ++cs) {
        var iv = ir[cs].replace(is, _$_543c[123]), io = iv.indexOf(im), ip, iu, cr, hQ;
        if (io >= 0) {
            ip = iv.substr(0, io);
            iu = iv.substr(io + 1)
        } else {
            ip = iv;
            iu = _$_543c[60]
        }
        ;cr = decodeURIComponent(ip);
        hQ = decodeURIComponent(iu);
        if (!ik(dl, cr)) {
            dl[cr] = hQ
        } else {
            if (il(dl[cr])) {
                dl[cr].push(hQ)
            } else {
                dl[cr] = [dl[cr], hQ]
            }
        }
    }
    ;return dl
}
var cP = 0;
var cO = 4;
var cQ = 0;
var cR = 1;
var cS = 2;
var cL = -1;
var cM = 0;
var cN = 8;
var cP = 0;
var fh = 1;
var ff = 3;
var cO = 4;
var fa = 5;
var cQ = 0;
var cR = 1;
var fj = -2;
var fc = -3;
var fb = -5;
var cL = -1;
var fd = 1;
var fg = 2;
var fi = 3;
var fe = 4;
var cM = 0;
var fk = 2;
var cN = 8;
var eO = 9;
var eP = 15;
var ek = 8;
var eI = 29;
var eJ = 256;
var eH = eJ + 1 + eI;
var ej = 30;
var ea = 19;
var eF = 2 * eH + 1;
var eM = 15;
var eR = 3;
var eN = 258;
var eQ = (eN + eR + 1);
var eU = 0x20;
var eG = 42;
var ez = 69;
var eS = 73;
var eg = 91;
var eE = 103;
var ef = 113;
var eB = 666;
var ee = 1;
var eb = 2;
var ed = 3;
var ec = 4;
var eT = 0x03;
var gG = 512;
var gP = 7;
var hn = 1;
var gT = 18;
var gU = 17;
var gS = 16;
var hh = 1;
var gz = 16;
var gH = 2;
function assign(dl) {
    var dn = Array.prototype.slice.call(arguments, 1);
    while (dn.length) {
        var bP = dn.shift();
        if (!bP) {
            continue
        }
        ;if (typeof bP !== _$_543c[2]) {
            throw new TypeError(bP + _$_543c[105])
        }
        ;for (var dm in bP) {
            if (dh(bP, dm)) {
                dl[dm] = bP[dm]
            }
        }
    }
    ;return dl
}

function cU() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = _$_543c[60];
    this.state = null;
    this.data_type = 2;
    this.adler = 0
}
function fl(dp) {
    var ds = dp.length;
    while (--ds >= 0) {
        dp[ds] = 0
    }
}
function ex() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = cN;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new Uint16Array(eF * 2);
    this.dyn_dtree = new Uint16Array((2 * ej + 1) * 2);
    this.bl_tree = new Uint16Array((2 * ea + 1) * 2);
    fl(this.dyn_ltree);
    fl(this.dyn_dtree);
    fl(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new Uint16Array(eM + 1);
    this.heap = new Uint16Array(2 * eH + 1);
    fl(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new Uint16Array(2 * eH + 1);
    fl(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0
}
var gu = new Array(eI);
var gL = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var gn = new Array(eN - eR + 1);
var gt = new Array(ej);
var gK = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var gm = new Array(gG);
var hg = new Array((eH + 2) * 2);
var hd = new Array(ej * 2);
var gJ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var gI = 256;
var gy = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
function gw(hu, ds) {
    var hv = 0;
    do {
        hv |= hu & 1;
        hu >>>= 1;
        hv <<= 1
    } while (--ds > 0);;return hv >>> 1
}
function gN(hC, hz, hO) {
    var hP = new Array(eM + 1);
    var hu = 0;
    var hJ;
    var dQ;
    for (hJ = 1; hJ <= eM; hJ++) {
        hP[hJ] = hu = (hu + hO[hJ - 1]) << 1
    }
    ;for (dQ = 0; dQ <= hz; dQ++) {
        var ds = hC[dQ * 2 + 1];
        if (ds === 0) {
            continue
        }
        ;hC[dQ * 2] = gw(hP[ds]++, ds)
    }
}
function hi(ih, ig, ie, hx, hL) {
    this.static_tree = ih;
    this.extra_bits = ig;
    this.extra_base = ie;
    this.elems = hx;
    this.max_length = hL;
    this.has_stree = ih && ih.length
}
function hk() {
    var dQ;
    var hJ;
    var bs;
    var hu;
    var hs;
    var hO = new Array(eM + 1);
    bs = 0;
    for (hu = 0; hu < eI - 1; hu++) {
        gu[hu] = bs;
        for (dQ = 0; dQ < (1 << gL[hu]); dQ++) {
            gn[bs++] = hu
        }
    }
    ;gn[bs - 1] = hu;
    hs = 0;
    for (hu = 0; hu < 16; hu++) {
        gt[hu] = hs;
        for (dQ = 0; dQ < (1 << gK[hu]); dQ++) {
            gm[hs++] = hu
        }
    }
    ;hs >>= 7;
    for (; hu < ej; hu++) {
        gt[hu] = hs << 7;
        for (dQ = 0; dQ < (1 << (gK[hu] - 7)); dQ++) {
            gm[256 + hs++] = hu
        }
    }
    ;for (hJ = 0; hJ <= eM; hJ++) {
        hO[hJ] = 0
    }
    ;dQ = 0;
    while (dQ <= 143) {
        hg[dQ * 2 + 1] = 8;
        dQ++;
        hO[8]++
    }
    ;while (dQ <= 255) {
        hg[dQ * 2 + 1] = 9;
        dQ++;
        hO[9]++
    }
    ;while (dQ <= 279) {
        hg[dQ * 2 + 1] = 7;
        dQ++;
        hO[7]++
    }
    ;while (dQ <= 287) {
        hg[dQ * 2 + 1] = 8;
        dQ++;
        hO[8]++
    }
    ;gN(hg, eH + 1, hO);
    for (dQ = 0; dQ < ej; dQ++) {
        hd[dQ * 2 + 1] = 5;
        hd[dQ * 2] = gw(dQ, 5)
    }
    ;hf = new hi(hg,gL,eJ + 1,eH,eM);
    hc = new hi(hd,gK,0,ej,eM);
    hb = new hi(new Array(0),gJ,0,ea,gP)
}
var he = false;
function hl(ii, ij) {
    this.dyn_tree = ii;
    this.max_code = 0;
    this.stat_desc = ij
}
function gO(fx) {
    var dQ;
    for (dQ = 0; dQ < eH; dQ++) {
        fx.dyn_ltree[dQ * 2] = 0
    }
    ;for (dQ = 0; dQ < ej; dQ++) {
        fx.dyn_dtree[dQ * 2] = 0
    }
    ;for (dQ = 0; dQ < ea; dQ++) {
        fx.bl_tree[dQ * 2] = 0
    }
    ;fx.dyn_ltree[gI * 2] = 1;
    fx.opt_len = fx.static_len = 0;
    fx.last_lit = fx.matches = 0
}
function gq(fx) {
    if (!he) {
        hk();
        he = true
    }
    ;fx.l_desc = new hl(fx.dyn_ltree,hf);
    fx.d_desc = new hl(fx.dyn_dtree,hc);
    fx.bl_desc = new hl(fx.bl_tree,hb);
    fx.bi_buf = 0;
    fx.bi_valid = 0;
    gO(fx)
}

function eu(da) {
    var fx;
    if (!da || !da.state) {
        return ey(da, fj)
    }
    ;da.total_in = da.total_out = 0;
    da.data_type = fk;
    fx = da.state;
    fx.pending = 0;
    fx.pending_out = 0;
    if (fx.wrap < 0) {
        fx.wrap = -fx.wrap
    }
    ;fx.status = (fx.wrap ? eG : ef);
    da.adler = (fx.wrap === 2) ? 0 : 1;
    fx.last_flush = cP;
    gq(fx);
    return cQ
}
function eh(fn, fp, fq, fo, fm) {
    this.good_length = fn;
    this.max_lazy = fp;
    this.nice_length = fq;
    this.max_chain = fo;
    this.func = fm
}
function ep(fx, ft) {
    var fG = 0xffff;
    if (fG > fx.pending_buf_size - 5) {
        fG = fx.pending_buf_size - 5
    }
    ;for (; ; ) {
        if (fx.lookahead <= 1) {
            eA(fx);
            if (fx.lookahead === 0 && ft === cP) {
                return ee
            }
            ;if (fx.lookahead === 0) {
                break
            }
        }
        ;fx.strstart += fx.lookahead;
        fx.lookahead = 0;
        var fH = fx.block_start + fG;
        if (fx.strstart === 0 || fx.strstart >= fH) {
            fx.lookahead = fx.strstart - fH;
            fx.strstart = fH;
            eC(fx, false);
            if (fx.strm.avail_out === 0) {
                return ee
            }
        }
        ;if (fx.strstart - fx.block_start >= (fx.w_size - eQ)) {
            eC(fx, false);
            if (fx.strm.avail_out === 0) {
                return ee
            }
        }
    }
    ;fx.insert = 0;
    if (ft === cO) {
        eC(fx, true);
        if (fx.strm.avail_out === 0) {
            return ed
        }
        ;return ec
    }
    ;if (fx.strstart > fx.block_start) {
        eC(fx, false);
        if (fx.strm.avail_out === 0) {
            return ee
        }
    }
    ;return ee
}
function el(fx, ft) {
    var fA;
    var fz;
    for (; ; ) {
        if (fx.lookahead < eQ) {
            eA(fx);
            if (fx.lookahead < eQ && ft === cP) {
                return ee
            }
            ;if (fx.lookahead === 0) {
                break
            }
        }
        ;fA = 0;
        if (fx.lookahead >= eR) {
            fx.ins_h = ((fx.ins_h << fx.hash_shift) ^ fx.window[fx.strstart + eR - 1]) & fx.hash_mask;
            fA = fx.prev[fx.strstart & fx.w_mask] = fx.head[fx.ins_h];
            fx.head[fx.ins_h] = fx.strstart
        }
        ;if (fA !== 0 && ((fx.strstart - fA) <= (fx.w_size - eQ))) {
            fx.match_length = eL(fx, fA)
        }
        ;if (fx.match_length >= eR) {
            fz = eZ._tr_tally(fx, fx.strstart - fx.match_start, fx.match_length - eR);
            fx.lookahead -= fx.match_length;
            if (fx.match_length <= fx.max_lazy_match && fx.lookahead >= eR) {
                fx.match_length--;
                do {
                    fx.strstart++;
                    fx.ins_h = ((fx.ins_h << fx.hash_shift) ^ fx.window[fx.strstart + eR - 1]) & fx.hash_mask;
                    fA = fx.prev[fx.strstart & fx.w_mask] = fx.head[fx.ins_h];
                    fx.head[fx.ins_h] = fx.strstart
                } while (--fx.match_length !== 0);;fx.strstart++
            } else {
                fx.strstart += fx.match_length;
                fx.match_length = 0;
                fx.ins_h = fx.window[fx.strstart];
                fx.ins_h = ((fx.ins_h << fx.hash_shift) ^ fx.window[fx.strstart + 1]) & fx.hash_mask
            }
        } else {
            fz = eZ._tr_tally(fx, 0, fx.window[fx.strstart]);
            fx.lookahead--;
            fx.strstart++
        }
        ;if (fz) {
            eC(fx, false);
            if (fx.strm.avail_out === 0) {
                return ee
            }
        }
    }
    ;fx.insert = ((fx.strstart < (eR - 1)) ? fx.strstart : eR - 1);
    if (ft === cO) {
        eC(fx, true);
        if (fx.strm.avail_out === 0) {
            return ed
        }
        ;return ec
    }
    ;if (fx.last_lit) {
        eC(fx, false);
        if (fx.strm.avail_out === 0) {
            return ee
        }
    }
    ;return eb
}
function eL(fx, gc) {
    var gb = fx.max_chain_length;
    var fD = fx.strstart;
    var ge;
    var ds;
    var ga = fx.prev_length;
    var gf = fx.nice_match;
    var gd = (fx.strstart > (fx.w_size - eQ)) ? fx.strstart - (fx.w_size - eQ) : 0;
    var fB = fx.window;
    var gi = fx.w_mask;
    var fC = fx.prev;
    var fE = fx.strstart + eN;
    var gh = fB[fD + ga - 1];
    var gg = fB[fD + ga];
    if (fx.prev_length >= fx.good_match) {
        gb >>= 2
    }
    ;if (gf > fx.lookahead) {
        gf = fx.lookahead
    }
    ;do {
        ge = gc;
        if (fB[ge + ga] !== gg || fB[ge + ga - 1] !== gh || fB[ge] !== fB[fD] || fB[++ge] !== fB[fD + 1]) {
            continue
        }
        ;fD += 2;
        ge++;
        do {} while (fB[++fD] === fB[++ge] && fB[++fD] === fB[++ge] && fB[++fD] === fB[++ge] && fB[++fD] === fB[++ge] && fB[++fD] === fB[++ge] && fB[++fD] === fB[++ge] && fB[++fD] === fB[++ge] && fB[++fD] === fB[++ge] && fD < fE);;ds = eN - (fE - fD);
        fD = fE - eN;
        if (ds > ga) {
            fx.match_start = gc;
            ga = ds;
            if (ds >= gf) {
                break
            }
            ;gh = fB[fD + ga - 1];
            gg = fB[fD + ga]
        }
    } while ((gc = fC[gc & gi]) > gd && --gb !== 0);;if (ga <= fx.lookahead) {
        return ga
    }
    ;return fx.lookahead
}
function dO(dP, dp, ds, dx) {
    var dR = (dP & 0xffff) | 0
        , dS = ((dP >>> 16) & 0xffff) | 0
        , dQ = 0;
    while (ds !== 0) {
        dQ = ds > 2000 ? 2000 : ds;
        ds -= dQ;
        do {
            dR = (dR + dp[dx++]) | 0;
            dS = (dS + dR) | 0
        } while (--dQ);;dR %= 65521;
        dS %= 65521
    }
    ;return (dR | (dS << 16)) | 0
}
function eY(da, dp, gl, bp) {
    var ds = da.avail_in;
    if (ds > bp) {
        ds = bp
    }
    ;if (ds === 0) {
        return 0
    }
    ;da.avail_in -= ds;
    di.arraySet(dp, da.input, da.next_in, ds, gl);
    if (da.state.wrap === 1) {
        da.adler = dO(da.adler, dp, ds, gl)
    } else {
        if (da.state.wrap === 2) {
            da.adler = dT(da.adler, dp, ds, gl)
        }
    }
    ;da.next_in += ds;
    da.total_in += ds;
    return ds
}
function eA(fx) {
    var fW = fx.w_size;
    var dm, dQ, fX, fY, cC;
    do {
        fY = fx.window_size - fx.lookahead - fx.strstart;
        if (fx.strstart >= fW + (fW - eQ)) {
            cK.arraySet(fx.window, fx.window, fW, fW, 0);
            fx.match_start -= fW;
            fx.strstart -= fW;
            fx.block_start -= fW;
            dQ = fx.hash_size;
            dm = dQ;
            do {
                fX = fx.head[--dm];
                fx.head[dm] = (fX >= fW ? fX - fW : 0)
            } while (--dQ);;dQ = fW;
            dm = dQ;
            do {
                fX = fx.prev[--dm];
                fx.prev[dm] = (fX >= fW ? fX - fW : 0)
            } while (--dQ);;fY += fW
        }
        ;if (fx.strm.avail_in === 0) {
            break
        }
        ;dQ = eY(fx.strm, fx.window, fx.strstart + fx.lookahead, fY);
        fx.lookahead += dQ;
        if (fx.lookahead + fx.insert >= eR) {
            cC = fx.strstart - fx.insert;
            fx.ins_h = fx.window[cC];
            fx.ins_h = ((fx.ins_h << fx.hash_shift) ^ fx.window[cC + 1]) & fx.hash_mask;
            while (fx.insert) {
                fx.ins_h = ((fx.ins_h << fx.hash_shift) ^ fx.window[cC + eR - 1]) & fx.hash_mask;
                fx.prev[cC & fx.w_mask] = fx.head[fx.ins_h];
                fx.head[fx.ins_h] = cC;
                cC++;
                fx.insert--;
                if (fx.lookahead + fx.insert < eR) {
                    break
                }
            }
        }
    } while (fx.lookahead < eQ && fx.strm.avail_in !== 0);
}
function gE(hs) {
    return hs < 256 ? gm[hs] : gm[256 + (hs >>> 7)]
}
function gs(fx, hs, ht) {
    fx.pending_buf[fx.d_buf + fx.last_lit * 2] = (hs >>> 8) & 0xff;
    fx.pending_buf[fx.d_buf + fx.last_lit * 2 + 1] = hs & 0xff;
    fx.pending_buf[fx.l_buf + fx.last_lit] = ht & 0xff;
    fx.last_lit++;
    if (hs === 0) {
        fx.dyn_ltree[ht * 2]++
    } else {
        fx.matches++;
        hs--;
        fx.dyn_ltree[(gn[ht] + eJ + 1) * 2]++;
        fx.dyn_dtree[gE(hs) * 2]++
    }
    ;return (fx.last_lit === fx.lit_bufsize - 1)
}
function gF(fx) {
    var hH = 0xf3ffc07f;
    var dQ;
    for (dQ = 0; dQ <= 31; dQ++,
        hH >>>= 1) {
        if ((hH & 1) && (fx.dyn_ltree[dQ * 2] !== 0)) {
            return hm
        }
    }
    ;if (fx.dyn_ltree[9 * 2] !== 0 || fx.dyn_ltree[10 * 2] !== 0 || fx.dyn_ltree[13 * 2] !== 0) {
        return hn
    }
    ;for (dQ = 32; dQ < eJ; dQ++) {
        if (fx.dyn_ltree[dQ * 2] !== 0) {
            return hn
        }
    }
    ;return hm
}
function ha(hC, dQ, fX, id) {
    var ic = dQ * 2;
    var ib = fX * 2;
    return (hC[ic] < hC[ib] || (hC[ic] === hC[ib] && id[dQ] <= id[fX]))
}
function gQ(fx, hC, cr) {
    var hQ = fx.heap[cr];
    var cw = cr << 1;
    while (cw <= fx.heap_len) {
        if (cw < fx.heap_len && ha(hC, fx.heap[cw + 1], fx.heap[cw], fx.depth)) {
            cw++
        }
        ;if (ha(hC, hQ, fx.heap[cw], fx.depth)) {
            break
        }
        ;fx.heap[cr] = fx.heap[cw];
        cr = cw;
        cw <<= 1
    }
    ;fx.heap[cr] = hQ
}
function gM(fx, hw) {
    var hC = hw.dyn_tree;
    var hz = hw.max_code;
    var hB = hw.stat_desc.static_tree;
    var hy = hw.stat_desc.has_stree;
    var hE = hw.stat_desc.extra_bits;
    var hI = hw.stat_desc.extra_base;
    var hL = hw.stat_desc.max_length;
    var hK;
    var dQ, fX;
    var hJ;
    var hN;
    var gk;
    var hM = 0;
    for (hJ = 0; hJ <= eM; hJ++) {
        fx.bl_count[hJ] = 0
    }
    ;hC[fx.heap[fx.heap_max] * 2 + 1] = 0;
    for (hK = fx.heap_max + 1; hK < eF; hK++) {
        dQ = fx.heap[hK];
        hJ = hC[hC[dQ * 2 + 1] * 2 + 1] + 1;
        if (hJ > hL) {
            hJ = hL;
            hM++
        }
        ;hC[dQ * 2 + 1] = hJ;
        if (dQ > hz) {
            continue
        }
        ;fx.bl_count[hJ]++;
        hN = 0;
        if (dQ >= hI) {
            hN = hE[dQ - hI]
        }
        ;gk = hC[dQ * 2];
        fx.opt_len += gk * (hJ + hN);
        if (hy) {
            fx.static_len += gk * (hB[dQ * 2 + 1] + hN)
        }
    }
    ;if (hM === 0) {
        return
    }
    ;do {
        hJ = hL - 1;
        while (fx.bl_count[hJ] === 0) {
            hJ--
        }
        ;fx.bl_count[hJ]--;
        fx.bl_count[hJ + 1] += 2;
        fx.bl_count[hL]--;
        hM -= 2
    } while (hM > 0);;for (hJ = hL; hJ !== 0; hJ--) {
        dQ = fx.bl_count[hJ];
        while (dQ !== 0) {
            fX = fx.heap[--hK];
            if (fX > hz) {
                continue
            }
            ;if (hC[fX * 2 + 1] !== hJ) {
                fx.opt_len += (hJ - hC[fX * 2 + 1]) * hC[fX * 2];
                hC[fX * 2 + 1] = hJ
            }
            ;dQ--
        }
    }
}
function gN(hC, hz, hO) {
    var hP = new Array(eM + 1);
    var hu = 0;
    var hJ;
    var dQ;
    for (hJ = 1; hJ <= eM; hJ++) {
        hP[hJ] = hu = (hu + hO[hJ - 1]) << 1
    }
    ;for (dQ = 0; dQ <= hz; dQ++) {
        var ds = hC[dQ * 2 + 1];
        if (ds === 0) {
            continue
        }
        ;hC[dQ * 2] = gw(hP[ds]++, ds)
    }
}

function gB(fx, hw) {
    var hC = hw.dyn_tree;
    var hB = hw.stat_desc.static_tree;
    var hy = hw.stat_desc.has_stree;
    var hx = hw.stat_desc.elems;
    var dQ, fX;
    var hz = -1;
    var hA;
    fx.heap_len = 0;
    fx.heap_max = eF;
    for (dQ = 0; dQ < hx; dQ++) {
        if (hC[dQ * 2] !== 0) {
            fx.heap[++fx.heap_len] = hz = dQ;
            fx.depth[dQ] = 0
        } else {
            hC[dQ * 2 + 1] = 0
        }
    }
    ;while (fx.heap_len < 2) {
        hA = fx.heap[++fx.heap_len] = (hz < 2 ? ++hz : 0);
        hC[hA * 2] = 1;
        fx.depth[hA] = 0;
        fx.opt_len--;
        if (hy) {
            fx.static_len -= hB[hA * 2 + 1]
        }
    }
    ;hw.max_code = hz;
    for (dQ = (fx.heap_len >> 1); dQ >= 1; dQ--) {
        gQ(fx, hC, dQ)
    }
    ;hA = hx;
    do {
        dQ = fx.heap[1];
        fx.heap[1] = fx.heap[fx.heap_len--];
        gQ(fx, hC, 1);
        fX = fx.heap[1];
        fx.heap[--fx.heap_max] = dQ;
        fx.heap[--fx.heap_max] = fX;
        hC[hA * 2] = hC[dQ * 2] + hC[fX * 2];
        fx.depth[hA] = (fx.depth[dQ] >= fx.depth[fX] ? fx.depth[dQ] : fx.depth[fX]) + 1;
        hC[dQ * 2 + 1] = hC[fX * 2 + 1] = hA;
        fx.heap[1] = hA++;
        gQ(fx, hC, 1)
    } while (fx.heap_len >= 2);;fx.heap[--fx.heap_max] = fx.heap[1];
    gM(fx, hw);
    gN(hC, hz, fx.bl_count)
}
function gV(fx, hC, hz) {
    var dQ;
    var hX = -1;
    var hT;
    var hW = hC[0 * 2 + 1];
    var hS = 0;
    var hU = 7;
    var hV = 4;
    if (hW === 0) {
        hU = 138;
        hV = 3
    }
    ;hC[(hz + 1) * 2 + 1] = 0xffff;
    for (dQ = 0; dQ <= hz; dQ++) {
        hT = hW;
        hW = hC[(dQ + 1) * 2 + 1];
        if (++hS < hU && hT === hW) {
            continue
        } else {
            if (hS < hV) {
                fx.bl_tree[hT * 2] += hS
            } else {
                if (hT !== 0) {
                    if (hT !== hX) {
                        fx.bl_tree[hT * 2]++
                    }
                    ;fx.bl_tree[gS * 2]++
                } else {
                    if (hS <= 10) {
                        fx.bl_tree[gU * 2]++
                    } else {
                        fx.bl_tree[gT * 2]++
                    }
                }
            }
        }
        ;hS = 0;
        hX = hT;
        if (hW === 0) {
            hU = 138;
            hV = 3
        } else {
            if (hT === hW) {
                hU = 6;
                hV = 3
            } else {
                hU = 7;
                hV = 4
            }
        }
    }
}
function gA(fx) {
    var ho;
    gV(fx, fx.dyn_ltree, fx.l_desc.max_code);
    gV(fx, fx.dyn_dtree, fx.d_desc.max_code);
    gB(fx, fx.bl_desc);
    for (ho = ea - 1; ho >= 3; ho--) {
        if (fx.bl_tree[gy[ho] * 2 + 1] !== 0) {
            break
        }
    }
    ;fx.opt_len += 3 * (ho + 1) + 5 + 5 + 4;
    return ho
}
function gR(fx, hR) {
    fx.pending_buf[fx.pending++] = (hR) & 0xff;
    fx.pending_buf[fx.pending++] = (hR >>> 8) & 0xff
}
function gX(fx, bu, bs) {
    if (fx.bi_valid > (gz - bs)) {
        fx.bi_buf |= (bu << fx.bi_valid) & 0xffff;
        gR(fx, fx.bi_buf);
        fx.bi_buf = bu >> (gz - fx.bi_valid);
        fx.bi_valid += bs - gz
    } else {
        fx.bi_buf |= (bu << fx.bi_valid) & 0xffff;
        fx.bi_valid += bs
    }
}
function gY(fx, dG, hC) {
    gX(fx, hC[dG * 2], hC[dG * 2 + 1])
}
function gC(fx, hF, hD) {
    var hs;
    var ht;
    var hG = 0;
    var hu;
    var hE;
    if (fx.last_lit !== 0) {
        do {
            hs = (fx.pending_buf[fx.d_buf + hG * 2] << 8) | (fx.pending_buf[fx.d_buf + hG * 2 + 1]);
            ht = fx.pending_buf[fx.l_buf + hG];
            hG++;
            if (hs === 0) {
                gY(fx, ht, hF)
            } else {
                hu = gn[ht];
                gY(fx, hu + eJ + 1, hF);
                hE = gL[hu];
                if (hE !== 0) {
                    ht -= gu[hu];
                    gX(fx, ht, hE)
                }
                ;hs--;
                hu = gE(hs);
                gY(fx, hu, hD);
                hE = gK[hu];
                if (hE !== 0) {
                    hs -= gt[hu];
                    gX(fx, hs, hE)
                }
            }
        } while (hG < fx.last_lit);
    }
    ;gY(fx, gI, hF)
}
function gx(fx) {
    if (fx.bi_valid > 8) {
        gR(fx, fx.bi_buf)
    } else {
        if (fx.bi_valid > 0) {
            fx.pending_buf[fx.pending++] = fx.bi_buf
        }
    }
    ;fx.bi_buf = 0;
    fx.bi_valid = 0
}
function gZ(fx, hC, hz) {
    var dQ;
    var hX = -1;
    var hT;
    var hW = hC[0 * 2 + 1];
    var hS = 0;
    var hU = 7;
    var hV = 4;
    if (hW === 0) {
        hU = 138;
        hV = 3
    }
    ;for (dQ = 0; dQ <= hz; dQ++) {
        hT = hW;
        hW = hC[(dQ + 1) * 2 + 1];
        if (++hS < hU && hT === hW) {
            continue
        } else {
            if (hS < hV) {
                do {
                    gY(fx, hT, fx.bl_tree)
                } while (--hS !== 0);
            } else {
                if (hT !== 0) {
                    if (hT !== hX) {
                        gY(fx, hT, fx.bl_tree);
                        hS--
                    }
                    ;gY(fx, gS, fx.bl_tree);
                    gX(fx, hS - 3, 2)
                } else {
                    if (hS <= 10) {
                        gY(fx, gU, fx.bl_tree);
                        gX(fx, hS - 3, 3)
                    } else {
                        gY(fx, gT, fx.bl_tree);
                        gX(fx, hS - 11, 7)
                    }
                }
            }
        }
        ;hS = 0;
        hX = hT;
        if (hW === 0) {
            hU = 138;
            hV = 3
        } else {
            if (hT === hW) {
                hU = 6;
                hV = 3
            } else {
                hU = 7;
                hV = 4
            }
        }
    }
}
function gW(fx, ia, hZ, hY) {
    var eX;
    gX(fx, ia - 257, 5);
    gX(fx, hZ - 1, 5);
    gX(fx, hY - 4, 4);
    for (eX = 0; eX < hY; eX++) {
        gX(fx, fx.bl_tree[gy[eX] * 2 + 1], 3)
    }
    ;gZ(fx, fx.dyn_ltree, ia - 1);
    gZ(fx, fx.dyn_dtree, hZ - 1)
}
function gp(fx, dp, hr, fZ) {
    var hp, hq;
    var ho = 0;
    if (fx.level > 0) {
        if (fx.strm.data_type === fk) {
            fx.strm.data_type = gF(fx)
        }
        ;gB(fx, fx.l_desc);
        gB(fx, fx.d_desc);
        ho = gA(fx);
        hp = (fx.opt_len + 3 + 7) >>> 3;
        hq = (fx.static_len + 3 + 7) >>> 3;
        if (hq <= hp) {
            hp = hq
        }
    } else {
        hp = hq = hr + 5
    }
    ;if ((hr + 4 <= hp) && (dp !== -1)) {
        gr(fx, dp, hr, fZ)
    } else {
        if (fx.strategy === fe || hq === hp) {
            gX(fx, (hh << 1) + (fZ ? 1 : 0), 3);
            gC(fx, hg, hd)
        } else {
            gX(fx, (gH << 1) + (fZ ? 1 : 0), 3);
            gW(fx, fx.l_desc.max_code + 1, fx.d_desc.max_code + 1, ho + 1);
            gC(fx, fx.dyn_ltree, fx.dyn_dtree)
        }
    }
    ;gO(fx);
    if (fZ) {
        gx(fx)
    }
}

function eC(fx, fZ) {
    gp(fx, (fx.block_start >= 0 ? fx.block_start : -1), fx.strstart - fx.block_start, fZ);
    fx.block_start = fx.strstart;
    eD(fx.strm)
}
function eo(fx, ft) {
    var fA;
    var fz;
    var fF;
    for (; ; ) {
        if (fx.lookahead < eQ) {
            eA(fx);
            if (fx.lookahead < eQ && ft === cP) {
                return ee
            }
            ;if (fx.lookahead === 0) {
                break
            }
        }
        ;fA = 0;
        if (fx.lookahead >= eR) {
            fx.ins_h = ((fx.ins_h << fx.hash_shift) ^ fx.window[fx.strstart + eR - 1]) & fx.hash_mask;
            fA = fx.prev[fx.strstart & fx.w_mask] = fx.head[fx.ins_h];
            fx.head[fx.ins_h] = fx.strstart
        }
        ;fx.prev_length = fx.match_length;
        fx.prev_match = fx.match_start;
        fx.match_length = eR - 1;
        if (fA !== 0 && fx.prev_length < fx.max_lazy_match && fx.strstart - fA <= (fx.w_size - eQ)) {
            fx.match_length = eL(fx, fA);
            if (fx.match_length <= 5 && (fx.strategy === fd || (fx.match_length === eR && fx.strstart - fx.match_start > 4096))) {
                fx.match_length = eR - 1
            }
        }
        ;if (fx.prev_length >= eR && fx.match_length <= fx.prev_length) {
            fF = fx.strstart + fx.lookahead - eR;
            fz = gs(fx, fx.strstart - 1 - fx.prev_match, fx.prev_length - eR);
            fx.lookahead -= fx.prev_length - 1;
            fx.prev_length -= 2;
            do {
                if (++fx.strstart <= fF) {
                    fx.ins_h = ((fx.ins_h << fx.hash_shift) ^ fx.window[fx.strstart + eR - 1]) & fx.hash_mask;
                    fA = fx.prev[fx.strstart & fx.w_mask] = fx.head[fx.ins_h];
                    fx.head[fx.ins_h] = fx.strstart
                }
            } while (--fx.prev_length !== 0);;fx.match_available = 0;
            fx.match_length = eR - 1;
            fx.strstart++;
            if (fz) {
                eC(fx, false);
                if (fx.strm.avail_out === 0) {
                    return ee
                }
            }
        } else {
            if (fx.match_available) {
                fz = gs(fx, 0, fx.window[fx.strstart - 1]);
                if (fz) {
                    eC(fx, false)
                }
                ;fx.strstart++;
                fx.lookahead--;
                if (fx.strm.avail_out === 0) {
                    return ee
                }
            } else {
                fx.match_available = 1;
                fx.strstart++;
                fx.lookahead--
            }
        }
    }
    ;if (fx.match_available) {
        fz = gs(fx, 0, fx.window[fx.strstart - 1]);
        fx.match_available = 0
    }
    ;fx.insert = fx.strstart < eR - 1 ? fx.strstart : eR - 1;
    if (ft === cO) {
        eC(fx, true);
        if (fx.strm.avail_out === 0) {
            return ed
        }
        ;return ec
    }
    ;if (fx.last_lit) {
        eC(fx, false);
        if (fx.strm.avail_out === 0) {
            return ee
        }
    }
    ;return eb
}
function en(fx, ft) {
    var fz;
    var fC;
    var fD, fE;
    var fB = fx.window;
    for (; ; ) {
        if (fx.lookahead <= eN) {
            eA(fx);
            if (fx.lookahead <= eN && ft === cP) {
                return ee
            }
            ;if (fx.lookahead === 0) {
                break
            }
        }
        ;fx.match_length = 0;
        if (fx.lookahead >= eR && fx.strstart > 0) {
            fD = fx.strstart - 1;
            fC = fB[fD];
            if (fC === fB[++fD] && fC === fB[++fD] && fC === fB[++fD]) {
                fE = fx.strstart + eN;
                do {} while (fC === fB[++fD] && fC === fB[++fD] && fC === fB[++fD] && fC === fB[++fD] && fC === fB[++fD] && fC === fB[++fD] && fC === fB[++fD] && fC === fB[++fD] && fD < fE);;fx.match_length = eN - (fE - fD);
                if (fx.match_length > fx.lookahead) {
                    fx.match_length = fx.lookahead
                }
            }
        }
        ;if (fx.match_length >= eR) {
            fz = eZ._tr_tally(fx, 1, fx.match_length - eR);
            fx.lookahead -= fx.match_length;
            fx.strstart += fx.match_length;
            fx.match_length = 0
        } else {
            fz = eZ._tr_tally(fx, 0, fx.window[fx.strstart]);
            fx.lookahead--;
            fx.strstart++
        }
        ;if (fz) {
            eC(fx, false);
            if (fx.strm.avail_out === 0) {
                return ee
            }
        }
    }
    ;fx.insert = 0;
    if (ft === cO) {
        eC(fx, true);
        if (fx.strm.avail_out === 0) {
            return ed
        }
        ;return ec
    }
    ;if (fx.last_lit) {
        eC(fx, false);
        if (fx.strm.avail_out === 0) {
            return ee
        }
    }
    ;return eb
}
function em(fx, ft) {
    var fz;
    for (; ; ) {
        if (fx.lookahead === 0) {
            eA(fx);
            if (fx.lookahead === 0) {
                if (ft === cP) {
                    return ee
                }
                ;break
            }
        }
        ;fx.match_length = 0;
        fz = eZ._tr_tally(fx, 0, fx.window[fx.strstart]);
        fx.lookahead--;
        fx.strstart++;
        if (fz) {
            eC(fx, false);
            if (fx.strm.avail_out === 0) {
                return ee
            }
        }
    }
    ;fx.insert = 0;
    if (ft === cO) {
        eC(fx, true);
        if (fx.strm.avail_out === 0) {
            return ed
        }
        ;return ec
    }
    ;if (fx.last_lit) {
        eC(fx, false);
        if (fx.strm.avail_out === 0) {
            return ee
        }
    }
    ;return eb
}

var ei;
ei = [new eh(0,0,0,0,ep), new eh(4,4,8,4,el), new eh(4,5,16,8,el), new eh(4,6,32,32,el), new eh(4,4,16,16,eo), new eh(8,16,32,32,eo), new eh(8,16,128,128,eo), new eh(8,32,128,256,eo), new eh(32,128,258,1024,eo), new eh(32,258,258,4096,eo)];

function eK(fx) {
    fx.window_size = 2 * fx.w_size;
    fl(fx.head);
    fx.max_lazy_match = ei[fx.level].max_lazy;
    fx.good_match = ei[fx.level].good_length;
    fx.nice_match = ei[fx.level].nice_length;
    fx.max_chain_length = ei[fx.level].max_chain;
    fx.strstart = 0;
    fx.block_start = 0;
    fx.lookahead = 0;
    fx.insert = 0;
    fx.match_length = fx.prev_length = eR - 1;
    fx.match_available = 0;
    fx.ins_h = 0
}
function et(da) {
    var fO = eu(da);
    if (fO === cQ) {
        eK(da.state)
    }
    ;return fO
}
function es(da, fI, fK, fM, fJ, fL) {
    if (!da) {
        return fj
    }
    ;var fN = 1;
    if (fI === cL) {
        fI = 6
    }
    ;if (fM < 0) {
        fN = 0;
        fM = -fM
    } else {
        if (fM > 15) {
            fN = 2;
            fM -= 16
        }
    }
    ;if (fJ < 1 || fJ > eO || fK !== cN || fM < 8 || fM > 15 || fI < 0 || fI > 9 || fL < 0 || fL > fe) {
        return ey(da, fj)
    }
    ;if (fM === 8) {
        fM = 9
    }
    ;var fx = new ex();
    da.state = fx;
    fx.strm = da;
    fx.wrap = fN;
    fx.gzhead = null;
    fx.w_bits = fM;
    fx.w_size = 1 << fx.w_bits;
    fx.w_mask = fx.w_size - 1;
    fx.hash_bits = fJ + 7;
    fx.hash_size = 1 << fx.hash_bits;
    fx.hash_mask = fx.hash_size - 1;
    fx.hash_shift = ~~((fx.hash_bits + eR - 1) / eR);
    fx.window = new Uint8Array(fx.w_size * 2);
    fx.head = new Uint16Array(fx.hash_size);
    fx.prev = new Uint16Array(fx.w_size);
    fx.lit_bufsize = 1 << (fJ + 6);
    fx.pending_buf_size = fx.lit_bufsize * 4;
    fx.pending_buf = new Uint8Array(fx.pending_buf_size);
    fx.d_buf = 1 * fx.lit_bufsize;
    fx.l_buf = (1 + 2) * fx.lit_bufsize;
    fx.level = fI;
    fx.strategy = fL;
    fx.method = fK;
    return et(da)
}
function string2buf(cC) {
    var dp, dG, dH, dI, cs, dJ = cC.length, dF = 0;
    for (dI = 0; dI < dJ; dI++) {
        dG = cC.charCodeAt(dI);
        if ((dG & 0xfc00) === 0xd800 && (dI + 1 < dJ)) {
            dH = cC.charCodeAt(dI + 1);
            if ((dH & 0xfc00) === 0xdc00) {
                dG = 0x10000 + ((dG - 0xd800) << 10) + (dH - 0xdc00);
                dI++
            }
        }
        ;dF += dG < 0x80 ? 1 : dG < 0x800 ? 2 : dG < 0x10000 ? 3 : 4
    }
    ;dp = new Uint8Array(dF);
    for (cs = 0,
             dI = 0; cs < dF; dI++) {
        dG = cC.charCodeAt(dI);
        if ((dG & 0xfc00) === 0xd800 && (dI + 1 < dJ)) {
            dH = cC.charCodeAt(dI + 1);
            if ((dH & 0xfc00) === 0xdc00) {
                dG = 0x10000 + ((dG - 0xd800) << 10) + (dH - 0xdc00);
                dI++
            }
        }
        ;if (dG < 0x80) {
            dp[cs++] = dG
        } else {
            if (dG < 0x800) {
                dp[cs++] = 0xC0 | (dG >>> 6);
                dp[cs++] = 0x80 | (dG & 0x3f)
            } else {
                if (dG < 0x10000) {
                    dp[cs++] = 0xE0 | (dG >>> 12);
                    dp[cs++] = 0x80 | (dG >>> 6 & 0x3f);
                    dp[cs++] = 0x80 | (dG & 0x3f)
                } else {
                    dp[cs++] = 0xf0 | (dG >>> 18);
                    dp[cs++] = 0x80 | (dG >>> 12 & 0x3f);
                    dp[cs++] = 0x80 | (dG >>> 6 & 0x3f);
                    dp[cs++] = 0x80 | (dG & 0x3f)
                }
            }
        }
    }
    ;return dp
}
function eW(fx, gj) {
    fx.pending_buf[fx.pending++] = (gj >>> 8) & 0xff;
    fx.pending_buf[fx.pending++] = gj & 0xff
}
var di = {
    arraySet: function(dq, dt, du, ds, dr) {
        if (dt.subarray && dq.subarray) {
            dq.set(dt.subarray(du, du + ds), dr);
            return
        }
        ;for (var cs = 0; cs < ds; cs++) {
            dq[dr + cs] = dt[du + cs]
        }
    },
    flattenChunks: function(dv) {
        var cs, dw, ds, dx, db, bk;
        ds = 0;
        for (cs = 0,
                 dw = dv.length; cs < dw; cs++) {
            ds += dv[cs].length
        }
        ;bk = new Uint8Array(ds);
        dx = 0;
        for (cs = 0,
                 dw = dv.length; cs < dw; cs++) {
            db = dv[cs];
            bk.set(db, dx);
            dx += db.length
        }
        ;return bk
    }
};
function eD(da) {
    var fx = da.state;
    var ds = fx.pending;
    if (ds > da.avail_out) {
        ds = da.avail_out
    }
    ;if (ds === 0) {
        return
    }
    ;di.arraySet(da.output, fx.pending_buf, fx.pending_out, ds, da.next_out);
    da.next_out += ds;
    fx.pending_out += ds;
    da.total_out += ds;
    da.avail_out -= ds;
    fx.pending -= ds;
    if (fx.pending === 0) {
        fx.pending_out = 0
    }
}
function cD_deflate(da, ft) {
    var fw, fx;
    var fr, fy;
    if (!da || !da.state || ft > fa || ft < 0) {
        return da ? ey(da, fj) : fj
    }
    ;fx = da.state;
    if (!da.output || (!da.input && da.avail_in !== 0) || (fx.status === eB && ft !== cO)) {
        return ey(da, (da.avail_out === 0) ? fb : fj)
    }
    ;fx.strm = da;
    fw = fx.last_flush;
    fx.last_flush = ft;
    if (fx.status === eG) {
        if (fx.wrap === 2) {
            da.adler = 0;
            eV(fx, 31);
            eV(fx, 139);
            eV(fx, 8);
            if (!fx.gzhead) {
                eV(fx, 0);
                eV(fx, 0);
                eV(fx, 0);
                eV(fx, 0);
                eV(fx, 0);
                eV(fx, fx.level === 9 ? 2 : (fx.strategy >= fg || fx.level < 2 ? 4 : 0));
                eV(fx, eT);
                fx.status = ef
            } else {
                eV(fx, (fx.gzhead.text ? 1 : 0) + (fx.gzhead.hcrc ? 2 : 0) + (!fx.gzhead.extra ? 0 : 4) + (!fx.gzhead.name ? 0 : 8) + (!fx.gzhead.comment ? 0 : 16));
                eV(fx, fx.gzhead.time & 0xff);
                eV(fx, (fx.gzhead.time >> 8) & 0xff);
                eV(fx, (fx.gzhead.time >> 16) & 0xff);
                eV(fx, (fx.gzhead.time >> 24) & 0xff);
                eV(fx, fx.level === 9 ? 2 : (fx.strategy >= fg || fx.level < 2 ? 4 : 0));
                eV(fx, fx.gzhead.os & 0xff);
                if (fx.gzhead.extra && fx.gzhead.extra.length) {
                    eV(fx, fx.gzhead.extra.length & 0xff);
                    eV(fx, (fx.gzhead.extra.length >> 8) & 0xff)
                }
                ;if (fx.gzhead.hcrc) {
                    da.adler = dT(da.adler, fx.pending_buf, fx.pending, 0)
                }
                ;fx.gzindex = 0;
                fx.status = ez
            }
        } else {
            var fu = (cN + ((fx.w_bits - 8) << 4)) << 8;
            var fv = -1;
            if (fx.strategy >= fg || fx.level < 2) {
                fv = 0
            } else {
                if (fx.level < 6) {
                    fv = 1
                } else {
                    if (fx.level === 6) {
                        fv = 2
                    } else {
                        fv = 3
                    }
                }
            }
            ;fu |= (fv << 6);
            if (fx.strstart !== 0) {
                fu |= eU
            }
            ;fu += 31 - (fu % 31);
            fx.status = ef;
            eW(fx, fu);
            if (fx.strstart !== 0) {
                eW(fx, da.adler >>> 16);
                eW(fx, da.adler & 0xffff)
            }
            ;da.adler = 1
        }
    }
    ;if (fx.status === ez) {
        if (fx.gzhead.extra) {
            fr = fx.pending;
            while (fx.gzindex < (fx.gzhead.extra.length & 0xffff)) {
                if (fx.pending === fx.pending_buf_size) {
                    if (fx.gzhead.hcrc && fx.pending > fr) {
                        da.adler = dT(da.adler, fx.pending_buf, fx.pending - fr, fr)
                    }
                    ;eD(da);
                    fr = fx.pending;
                    if (fx.pending === fx.pending_buf_size) {
                        break
                    }
                }
                ;eV(fx, fx.gzhead.extra[fx.gzindex] & 0xff);
                fx.gzindex++
            }
            ;if (fx.gzhead.hcrc && fx.pending > fr) {
                da.adler = dT(da.adler, fx.pending_buf, fx.pending - fr, fr)
            }
            ;if (fx.gzindex === fx.gzhead.extra.length) {
                fx.gzindex = 0;
                fx.status = eS
            }
        } else {
            fx.status = eS
        }
    }
    ;if (fx.status === eS) {
        if (fx.gzhead.name) {
            fr = fx.pending;
            do {
                if (fx.pending === fx.pending_buf_size) {
                    if (fx.gzhead.hcrc && fx.pending > fr) {
                        da.adler = dT(da.adler, fx.pending_buf, fx.pending - fr, fr)
                    }
                    ;eD(da);
                    fr = fx.pending;
                    if (fx.pending === fx.pending_buf_size) {
                        fy = 1;
                        break
                    }
                }
                ;if (fx.gzindex < fx.gzhead.name.length) {
                    fy = fx.gzhead.name.charCodeAt(fx.gzindex++) & 0xff
                } else {
                    fy = 0
                }
                ;eV(fx, fy)
            } while (fy !== 0);;if (fx.gzhead.hcrc && fx.pending > fr) {
                da.adler = dT(da.adler, fx.pending_buf, fx.pending - fr, fr)
            }
            ;if (fy === 0) {
                fx.gzindex = 0;
                fx.status = eg
            }
        } else {
            fx.status = eg
        }
    }
    ;if (fx.status === eg) {
        if (fx.gzhead.comment) {
            fr = fx.pending;
            do {
                if (fx.pending === fx.pending_buf_size) {
                    if (fx.gzhead.hcrc && fx.pending > fr) {
                        da.adler = dT(da.adler, fx.pending_buf, fx.pending - fr, fr)
                    }
                    ;eD(da);
                    fr = fx.pending;
                    if (fx.pending === fx.pending_buf_size) {
                        fy = 1;
                        break
                    }
                }
                ;if (fx.gzindex < fx.gzhead.comment.length) {
                    fy = fx.gzhead.comment.charCodeAt(fx.gzindex++) & 0xff
                } else {
                    fy = 0
                }
                ;eV(fx, fy)
            } while (fy !== 0);;if (fx.gzhead.hcrc && fx.pending > fr) {
                da.adler = dT(da.adler, fx.pending_buf, fx.pending - fr, fr)
            }
            ;if (fy === 0) {
                fx.status = eE
            }
        } else {
            fx.status = eE
        }
    }
    ;if (fx.status === eE) {
        if (fx.gzhead.hcrc) {
            if (fx.pending + 2 > fx.pending_buf_size) {
                eD(da)
            }
            ;if (fx.pending + 2 <= fx.pending_buf_size) {
                eV(fx, da.adler & 0xff);
                eV(fx, (da.adler >> 8) & 0xff);
                da.adler = 0;
                fx.status = ef
            }
        } else {
            fx.status = ef
        }
    }
    ;if (fx.pending !== 0) {
        eD(da);
        if (da.avail_out === 0) {
            fx.last_flush = -1;
            return cQ
        }
    } else {
        if (da.avail_in === 0 && eX(ft) <= eX(fw) && ft !== cO) {
            return ey(da, fb)
        }
    }
    ;if (fx.status === eB && da.avail_in !== 0) {
        return ey(da, fb)
    }
    ;if (da.avail_in !== 0 || fx.lookahead !== 0 || (ft !== cP && fx.status !== eB)) {
        var fs = (fx.strategy === fg) ? em(fx, ft) : (fx.strategy === fi ? en(fx, ft) : ei[fx.level].func(fx, ft));
        if (fs === ed || fs === ec) {
            fx.status = eB
        }
        ;if (fs === ee || fs === ed) {
            if (da.avail_out === 0) {
                fx.last_flush = -1
            }
            ;return cQ
        }
        ;if (fs === eb) {
            if (ft === fh) {
                eZ._tr_align(fx)
            } else {
                if (ft !== fa) {
                    eZ._tr_stored_block(fx, 0, 0, false);
                    if (ft === ff) {
                        fl(fx.head);
                        if (fx.lookahead === 0) {
                            fx.strstart = 0;
                            fx.block_start = 0;
                            fx.insert = 0
                        }
                    }
                }
            }
            ;eD(da);
            if (da.avail_out === 0) {
                fx.last_flush = -1;
                return cQ
            }
        }
    }
    ;if (ft !== cO) {
        return cQ
    }
    ;if (fx.wrap <= 0) {
        return cR
    }
    ;if (fx.wrap === 2) {
        eV(fx, da.adler & 0xff);
        eV(fx, (da.adler >> 8) & 0xff);
        eV(fx, (da.adler >> 16) & 0xff);
        eV(fx, (da.adler >> 24) & 0xff);
        eV(fx, da.total_in & 0xff);
        eV(fx, (da.total_in >> 8) & 0xff);
        eV(fx, (da.total_in >> 16) & 0xff);
        eV(fx, (da.total_in >> 24) & 0xff)
    } else {
        eW(fx, da.adler >>> 16);
        eW(fx, da.adler & 0xffff)
    }
    ;eD(da);
    if (fx.wrap > 0) {
        fx.wrap = -fx.wrap
    }
    ;return fx.pending !== 0 ? cQ : cR
}
function cE(de) {
    if (!(this instanceof cE)) {
        return new cE(de)
    }
    ;this.options = assign({
        level: -1,
        method: 8,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: 0,
        to: _$_543c[60]
    }, de || {});
    var dg = this.options;
    if (dg.raw && (dg.windowBits > 0)) {
        dg.windowBits = -dg.windowBits
    } else {
        if (dg.gzip && (dg.windowBits > 0) && (dg.windowBits < 16)) {
            dg.windowBits += 16
        }
    }
    ;this.err = 0;
    this.msg = _$_543c[60];
    this.ended = false;
    this.chunks = [];
    this.strm = new cU();
    this.strm.avail_out = 0;
    var cZ = es(this.strm, dg.level, dg.method, dg.windowBits, dg.memLevel, dg.strategy);
    if (cZ !== cQ) {
        throw new Error(cH[cZ])
    }
    ;if (dg.header) {
        cT.deflateSetHeader(this.strm, dg.header)
    }
    ;if (dg.dictionary) {
        var df;
        if (typeof dg.dictionary === _$_543c[91]) {
            df = cI.string2buf(dg.dictionary)
        } else {
            if (cJ.call(dg.dictionary) === _$_543c[104]) {
                df = new Uint8Array(dg.dictionary)
            } else {
                df = dg.dictionary
            }
        }
        ;cZ = cT.deflateSetDictionary(this.strm, df);
        if (cZ !== cQ) {
            throw new Error(cH[cZ])
        }
        ;this._dict_set = true
    }
}
function shrinkBuf(dp, bp) {
    if (dp.length === bp) {
        return dp
    }
    ;if (dp.subarray) {
        return dp.subarray(0, bp)
    }
    ;dp.length = bp;
    return dp
}
function eq(da) {
    var cZ;
    if (!da || !da.state) {
        return fj
    }
    ;cZ = da.state.status;
    if (cZ !== eG && cZ !== ez && cZ !== eS && cZ !== eg && cZ !== eE && cZ !== ef && cZ !== eB) {
        return ey(da, fj)
    }
    ;da.state = null;
    return cZ === ef ? ey(da, fc) : cQ
}
cE.prototype.push = function(cX, cY) {
    var da = this.strm;
    var cW = this.options.chunkSize;
    var cZ, cV;
    if (this.ended) {
        return false
    }
    ;cV = (cY === ~~cY) ? cY : ((cY === true) ? cO : cP);
    if (typeof cX === _$_543c[91]) {
        da.input = string2buf(cX)
    } else {
        if (cJ.call(cX) === _$_543c[104]) {
            da.input = new Uint8Array(cX)
        } else {
            da.input = cX
        }
    }
    ;da.next_in = 0;
    da.avail_in = da.input.length;
    do {
        if (da.avail_out === 0) {
            da.output = new Uint8Array(cW);
            da.next_out = 0;
            da.avail_out = cW
        }
        ;cZ = cD_deflate(da, cV);
        if (cZ !== cR && cZ !== cQ) {
            this.onEnd(cZ);
            this.ended = true;
            return false
        }
        ;if (da.avail_out === 0 || (da.avail_in === 0 && (cV === cO || cV === cS))) {
            if (this.options.to === _$_543c[91]) {
                this.onData(cI.buf2binstring(cK.shrinkBuf(da.output, da.next_out)))
            } else {
                this.onData(shrinkBuf(da.output, da.next_out))
            }
        }
    } while ((da.avail_in > 0 || da.avail_out === 0) && cZ !== cR);;if (cV === cO) {
        cZ = eq(this.strm);
        this.onEnd(cZ);
        this.ended = true;
        return cZ === cQ
    }
    ;if (cV === cS) {
        this.onEnd(cQ);
        da.avail_out = 0;
        return true
    }
    ;return true
}
function flattenChunks(dv) {
    var cs, dw, ds, dx, db, bk;
    ds = 0;
    for (cs = 0,
             dw = dv.length; cs < dw; cs++) {
        ds += dv[cs].length
    }
    ;bk = new Uint8Array(ds);
    dx = 0;
    for (cs = 0,
             dw = dv.length; cs < dw; cs++) {
        db = dv[cs];
        bk.set(db, dx);
        dx += db.length
    }
    ;return bk
}
;
cE.prototype.onData = function(db) {
    this.chunks.push(db)
}
;
cE.prototype.onEnd = function(cZ) {
    if (cZ === cQ) {
        if (this.options.to === _$_543c[91]) {
            this.result = this.chunks.join(_$_543c[60])
        } else {
            this.result = flattenChunks(this.chunks)
        }
    }
    ;this.chunks = [];
    this.err = cZ;
    this.msg = this.strm.msg
}
;

function cD(dd, de) {
    var dc = new cE(de);
    dc.push(dd, true);
    if (dc.err) {
        throw dc.msg || cH[dc.err]
    }
    ;return dc.result
}
var iE = function(cC, bx) {
    if (typeof (cC) === _$_543c[91]) {
        return cC.charCodeAt(bx)
    } else {
        if (cC instanceof Array) {
            return cC[bx]
        } else {
            if (cC instanceof Uint8Array) {
                return cC[bx]
            }
        }
    }
    ;return 0
};
var iC = _$_543c[127];
var iF = function(iG) {
    return iC.charAt(iG)
};
function iD(cC) {
    var iH = [];
    var dY = 0;
    var bs = cC.length;
    var dG = 0;
    for (var cs = 0; cs < bs; ++cs) {
        dY += 1;
        if (dY === 3) {
            dY = 0
        }
        ;dG = iE(cC, cs);
        if (dY === 0) {
            iH.push(iF(((iE(cC, cs - 1) << 2) | (dG >> 6)) & 0x3F), iF(dG & 0x3F))
        } else {
            if (dY === 1) {
                iH.push(iF((dG >> 2) & 0x3F))
            } else {
                iH.push(iF(((iE(cC, cs - 1) << 4) | (dG >> 4)) & 0x3F))
            }
        }
        ;if (cs === bs - 1 && dY > 0) {
            iH.push(iF((dG << ((3 - dY) << 1)) & 0x3F))
        }
    }
    ;if (dY) {
        while (dY < 3) {
            dY += 1;
            iH.push(_$_543c[122])
        }
    }
    ;return iH.join(_$_543c[60])
}
var iI = function(jc) {
    jc = cD(JSON.stringify(jc));
    jc = iD(jc);
    return jc
};
var iJ = function(je) {
    var jd = [];
    var ck = Object.keys(je).sort();
    ck.forEach(function(jf, bx) {
        if (jf !== _$_543c[136] && jf !== _$_543c[137]) {
            jd.push(jf + _$_543c[122] + je[jf])
        }
    });
    jd = jd.join(_$_543c[121]);
    return iI(jd)
};

function param(e, n=Tru) {
    var r = [];
    return r.add = function(e, n) {
        e_1(n) && (n = n()),
        null == n && (n = ""),
            this.push(P(e) + "=" + P(n))
    }
        ,
        v(r, e, n),
        r.join("&").replace(/%20/g, "+")

}

// data
var e={"needRegions":7,"channel":6,"initialLat":39.912854,"initialLng":116.459635,"geoType":2};
var n=true;
o=param(e,!0);

a = ('/waimai/ajax/newm/homehead' + "&" + o).replace(/[&?]{1,2}/, "?");
function get_token(jv) {
    var jw;
    var jx = {};
    if (typeof jv === _$_543c[91]) {
        jx = exports(jv.split(_$_543c[146])[1])
    } else {
        if (typeof jv === _$_543c[2]) {
            jx = jv
        }
    }
    ;iP.sign = iJ(jx);
    iP.cts = new Date().getTime();
    jw = iI(iP);

    if ("rohrdata" && typeof (window) !== _$_543c[0]) {
        window[Rohr_Opt.LogVal] = encodeURIComponent(jw)
    }

    ;return jw
}
mt_token=get_token(a);
console.log(mt_token)
"""

